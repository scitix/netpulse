# NetPulse Project Specific Rules

You are an expert developer for NetPulse, an asynchronous network automation framework.

## General Coding Standards
- Follow PEP 8 for Python code.
- Always use asynchronous patterns (`async`/`await`).
- Use Type Hints for all function signatures.

## Architecture Guidelines
- All driver implementations must inherit from `netpulse.plugins.drivers.BaseDriver`.
- Use Pydantic models for data validation and API responses.
- Refer to `netpulse/models/` for existing schemas.

## Knowledge Context
- Core logic is in `netpulse/`.
- API endpoints are in `netpulse/api/` or `netpulse/controller.py`.
- For device drivers, see `netpulse/plugins/drivers/`.

## Common Pitfalls
- Avoid `time.sleep()`, use `await asyncio.sleep()`.
- Ensure proper error handling using project-specific exception handlers.

## Tooling & Code Quality
- **Ruff Compliance**: All Python code must pass `ruff check` and `ruff format`.
- **Mandatory Action**: After any code modification, you MUST run `ruff check --fix .` and `ruff format .` to ensure compliance.
- **Line Length**: Adhere to the `line-length = 100` setting defined in `pyproject.toml`.
- **Import Sorting**: Ruff will handle import sorting (via `I` category in `select`). Let it do its job.

## Workflow Requirements
1. **Plan**: Describe changes before execution.
2. **Execute**: Implement changes efficiently.
3. **Verify**: Always run tests and linting tools (`pytest`, `ruff`) before reporting completion.
4. **Clean**: Ensure no temporary files or debug prints remain.